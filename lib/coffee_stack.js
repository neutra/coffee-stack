// Generated by CoffeeScript 1.6.2
(function() {
  var DEBUG, SourceMap, findAllMaps, formatSourcePosition, fs, getSourceMapping, loadV3SourceMap, loadV3Sourcemaps, mainModule, patchStackTrace, patched, path, vlqDecodeValue, _ref;

  fs = require('fs');

  path = require('path');

  fs.existsSync || (fs.existsSync = path.existsSync);

  _ref = require('./sourcemap'), SourceMap = _ref.SourceMap, vlqDecodeValue = _ref.vlqDecodeValue;

  DEBUG = false;

  mainModule = require.main;

  patched = false;

  patchStackTrace = function() {
    var coffee, err;

    if (patched) {
      return;
    }
    patched = true;
    mainModule._sourceMaps || (mainModule._sourceMaps = {});
    try {
      coffee = require('coffee-script');
    } catch (_error) {
      err = _error;
      coffee = {
        run: {}
      };
    }
    return Error.prepareStackTrace = function(err, stack) {
      var frames, _ref1;

      frames = (function() {
        var frame, pos, _i, _len, _results;

        _results = [];
        for (_i = 0, _len = stack.length; _i < _len; _i++) {
          frame = stack[_i];
          if (!(frame.getFunction() !== coffee.run)) {
            continue;
          }
          pos = formatSourcePosition(frame, getSourceMapping);
          _results.push("  at " + pos);
        }
        return _results;
      })();
      return "" + err.name + ": " + ((_ref1 = err.message) != null ? _ref1 : '') + "\n" + (frames.join('\n')) + "\n";
    };
  };

  formatSourcePosition = function(frame, getSourceMapping) {
    var as, column, fileLocation, fileName, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;

    fileName = null;
    fileLocation = '';
    if (frame.isNative()) {
      fileLocation = "native";
    } else {
      if (frame.isEval()) {
        fileName = frame.getScriptNameOrSourceURL();
        if (!fileName) {
          fileLocation = "" + (frame.getEvalOrigin()) + ", ";
        }
      } else {
        fileName = frame.getFileName();
      }
      fileName || (fileName = "<anonymous>");
      line = frame.getLineNumber();
      column = frame.getColumnNumber();
      fileLocation = "" + fileName + ":" + line + ":" + column;
      if (source = getSourceMapping(fileName, line, column)) {
        fileLocation += ", <coffee>:" + source[0] + ":" + source[1];
      }
    }
    functionName = frame.getFunctionName() || "<anonymous>";
    isConstructor = frame.isConstructor();
    isMethodCall = !(frame.isToplevel() || isConstructor);
    if (isMethodCall) {
      methodName = frame.getMethodName();
      typeName = frame.getTypeName();
      if (functionName) {
        tp = as = '';
        if (typeName && functionName.indexOf(typeName)) {
          tp = "" + typeName + ".";
        }
        if (methodName && functionName.indexOf("." + methodName) !== functionName.length - methodName.length - 1) {
          as = " [as " + methodName + "]";
          return "" + tp + functionName + as + " (" + fileLocation + ")";
        } else {
          return "" + typeName + "." + (methodName || '<anonymous>') + " (" + fileLocation + ")";
        }
      }
    } else if (isConstructor) {
      return "new " + (functionName || '<anonymous>') + " (" + fileLocation + ")";
    } else if (functionName) {
      return "" + functionName + " (" + fileLocation + ")";
    } else {
      return fileLocation;
    }
  };

  getSourceMapping = function(filename, line, column) {
    var answer, sourceMap;

    sourceMap = mainModule._sourceMaps[filename];
    if (!sourceMap) {
      return null;
    }
    answer = sourceMap.getSourcePosition([line - 1, column - 1]);
    if (answer) {
      return [answer[0] + 1, answer[1] + 1];
    } else {
      return null;
    }
  };

  loadV3Sourcemaps = function(dir) {
    var maps;

    findAllMaps(dir, maps = []);
    return maps.forEach(function(file) {
      var err, sourceMap;

      try {
        sourceMap = loadV3SourceMap(file.map);
      } catch (_error) {
        err = _error;
        if (DEBUG) {
          console.log("load source map error: " + file.map);
        }
        if (DEBUG) {
          console.log(err.stack);
        }
        return;
      }
      if (sourceMap) {
        mainModule._sourceMaps[file.js] = sourceMap;
      }
      if (DEBUG) {
        return console.log("source map loaded: " + file.js);
      }
    });
  };

  findAllMaps = function(dir, maps) {
    var items;

    items = fs.readdirSync(dir);
    return items.forEach(function(name) {
      var err, fullname, jsName, stat;

      fullname = path.join(dir, name);
      try {
        stat = fs.statSync(fullname);
      } catch (_error) {
        err = _error;
        return;
      }
      if (stat.isDirectory()) {
        return findAllMaps(fullname, maps);
      } else if (/\.map$/.test(name)) {
        jsName = fullname.replace(/\.map$/, '.js');
        if (fs.existsSync(jsName)) {
          return maps.push({
            map: fullname,
            js: jsName
          });
        }
      }
    });
  };

  loadV3SourceMap = function(file) {
    var d, fragment, generatedColumn, generatedLine, lastGeneratedColumn, lastSourceColumn, lastSourceLine, line, lineNo, option, raw, result, sourceColumn, sourceLine, v3, _, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

    raw = fs.readFileSync(file, 'utf8');
    if (raw.charCodeAt(0) === 0xFEFF) {
      raw = raw.substring(1);
    }
    v3 = JSON.parse(raw);
    raw = null;
    result = new SourceMap;
    option = {
      noReplace: true
    };
    lineNo = 0;
    lastGeneratedColumn = 0;
    lastSourceLine = 0;
    lastSourceColumn = 0;
    _ref1 = v3.mappings.split(';');
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      line = _ref1[_i];
      ++lineNo;
      lastGeneratedColumn = 0;
      _ref2 = line.split(',');
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        fragment = _ref2[_j];
        if (!(fragment.length > 0)) {
          continue;
        }
        _ref3 = vlqDecodeValue(fragment), generatedColumn = _ref3[0], d = _ref3[1];
        generatedColumn += lastGeneratedColumn;
        fragment = fragment.slice(d);
        _ref4 = vlqDecodeValue(fragment), _ = _ref4[0], d = _ref4[1];
        generatedLine = lineNo;
        fragment = fragment.slice(d);
        _ref5 = vlqDecodeValue(fragment), sourceLine = _ref5[0], d = _ref5[1];
        sourceLine += lastSourceLine;
        fragment = fragment.slice(d);
        _ref6 = vlqDecodeValue(fragment), sourceColumn = _ref6[0], d = _ref6[1];
        sourceColumn += lastSourceColumn;
        result.addMapping([sourceLine, sourceColumn], [generatedLine, generatedColumn], option);
        lastGeneratedColumn = generatedColumn;
        lastSourceLine = sourceLine;
        lastSourceColumn = sourceColumn;
      }
    }
    return result;
  };

  exports.patch = function(dir) {
    if (dir == null) {
      dir = __dirname;
    }
    patchStackTrace();
    return loadV3Sourcemaps(dir);
  };

}).call(this);

/*
//@ sourceMappingURL=coffee_stack.map
*/
